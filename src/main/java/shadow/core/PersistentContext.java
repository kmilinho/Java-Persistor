package shadow.core;

import java.lang.annotation.Annotation;
import java.lang.reflect.Field;
import java.math.BigDecimal;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.function.Predicate;
import java.util.stream.Collectors;

import javax.sql.DataSource;

import shadow.annotations.ColumnMap;
import shadow.annotations.ID;
import shadow.annotations.PersistentClass;
import shadow.exceptions.NotValidPersistentClassException;

public class PersistentContext<T>  {

	private DataSource dataSource;
	private Field[] _fields;
	private String _table;
	private int _fields_length;
	private String[] _column_names;
	private Field _id;
	private String _id_column_name;
	private boolean autoGeneratedKey;
	private Class<T> _class;


	/**
	 * 
	 * @param datasource
	 * @param _class
	 * @throws NotValidPersistentClassException If the class is not annotated as @PersistentClass or
	 * if the T class doesn't have public getters for all the persistent fields.
	 */
	public PersistentContext(DataSource datasource, Class<T> _class)
			throws NotValidPersistentClassException{

		if(!_class.isAnnotationPresent(PersistentClass.class)){
			throw new NotValidPersistentClassException("The object must be an instance of a class annotated with @PersistentCLass");
		}

		this.dataSource = datasource;
		this._fields = _class.getDeclaredFields();
		Annotation class_an = _class.getAnnotation(PersistentClass.class);
		this._table = ((PersistentClass) class_an).table();
		this._fields_length = this._fields.length;
		this._column_names = new String[this._fields_length];
		this._class = _class;

		Annotation annotation;
		boolean found_id = false;
		for(int i = 0; i < this._fields_length; i++ ){
			if(this._fields[i].isAnnotationPresent(ColumnMap.class)){
				this._fields[i].setAccessible(true);
				annotation = this._fields[i].getAnnotation(ColumnMap.class);
				this._column_names[i] = ((ColumnMap) annotation).column();	

				if(this._fields[i].isAnnotationPresent(ID.class)){	
					if(found_id){
						//TODO Allow compound keys.
						throw new NotValidPersistentClassException("Compound keys are not currently supported.");
					}
					this._id_column_name = this._column_names[i];
					this._id =  this._fields[i];
					if(!this._id.getType().equals(long.class) && !this._id.getType().equals(Long.class)){
						throw new NotValidPersistentClassException("The class @ID element must be long when is autogenerated.");
					}
					annotation = this._fields[i].getAnnotation(ID.class);
					this.autoGeneratedKey = ((ID) annotation).autogenerated();	
					found_id = true;
				}

			}
		}
		if(!found_id){
			throw new NotValidPersistentClassException("The class must have an @ID field.");
		}

	}

	/**
	 * 
	 * @param t Generic object to persist
	 * @throws
	 * 
	 */
	//TODO: batch
	@SafeVarargs
	public final void insert(T... objs)
			throws SQLException{

		List<Long> ids = new ArrayList<Long>();
		

		Connection connection = this.dataSource.getConnection();
		PreparedStatement stmt = null;
		try {
			stmt = generateInsertPrepareStatement(connection, Arrays.asList(objs));
		} catch (IllegalArgumentException  | IllegalAccessException e) {
			//TODO
			e.printStackTrace();
		}
		if(stmt != null){
			ResultSet rs;
			System.out.println("EXECUTING QUERY: " + stmt.toString());
			stmt.executeUpdate();
			rs = stmt.getGeneratedKeys();

			while (rs.next()) {
				ids.add(rs.getLong(1));
			}	
			rs.close();
			stmt.close();
		}
		connection.close();
		if(this.autoGeneratedKey){
			this._id.setAccessible(true);
			try {
				for(int i = 0; i < objs.length; i++){
					this._id.setLong(objs[i], ids.get(i));
				}
			} catch (IllegalArgumentException | IllegalAccessException e) {
				//TODO
				e.printStackTrace();

			}
		}
	}

	/**
	 * 
	 * @param ts List of Generic objects to persist
	 * @throws SQLException If an error occurs while accessing the Data Base.
	 * @throws IllegalAccessException 
	 * @throws IllegalArgumentException 
	 * 
	 */
	//TODO: batch
	public void insert(List<T> ts)
			throws SQLException{

	}


	/**
	 * 
	 * @param t Generic object to persist
	 * @return Auto-generated key created as a result of executing the insert on the Data Base. 0 if no Auto Gererated Key.
	 * @throws SQLException If an error occurs while accessing the Data Base.
	 */
	public long insertAndReturnId(T t)
			throws SQLException{

		long id = 0;

		Connection connection = this.dataSource.getConnection();
		PreparedStatement stmt = null;
		try {
			stmt = generateInsertPrepareStatement(connection, Arrays.asList(t));
		} catch (IllegalArgumentException  | IllegalAccessException e) {
			//TODO
			e.printStackTrace();

		}

		ResultSet rs;
		System.out.println("EXECUTING QUERY: " + stmt.toString());
		stmt.executeUpdate();
		rs = stmt.getGeneratedKeys();

		if (rs.next()) {
			id = rs.getLong(1);
		}
		rs.close();
		stmt.close();

		connection.close();
		if(this.autoGeneratedKey){
			this._id.setAccessible(true);
			try {
				this._id.setLong(t, id);
			} catch (IllegalArgumentException | IllegalAccessException e) {
				//TODO
				e.printStackTrace();
			}
		}
		return id;
	}

	/**
	 * 
	 * @param id Primary Key of the object T to be fetch on the Data Base.
	 * @return T instance with the data found on the Data Base
	 * @throws SQLException
	 */
	public T selectById(long id)
			throws SQLException{

		String selectSQL = "SELECT * FROM " + this._table +" WHERE " + this._id_column_name + " = ?";
		Connection connection = this.dataSource.getConnection();
		PreparedStatement stmt = null;
		stmt = connection.prepareStatement(selectSQL);
		stmt.setLong(1, id);
		System.out.println("EXECUTING QUERY: " + stmt.toString());
		ResultSet rs = stmt.executeQuery();
		T result = null;
		if (rs.next()){
			result = createInstance(rs);
		}
		rs.close();
		stmt.close();
		connection.close();
		return result;
	}

	//TODO
	public List<T> select(Filter filter){
		List<T> result = new ArrayList<T>();
		return result;
	}

	//TODO
	public PaginatedList<T> paginatedSelect(Filter filter){
		return null;
	}

	/**
	 * This methods is experimental, used just as a java 8 integration proof of concept (Not part of the Shadow API).
	 * Select all the records from the database and then filter the result set using
	 * a predicate. A predicate is a function that returns a boolean.
	 * @param predicate Functional interface (lambda) for filtering.
	 * @return Filtered List, containing only the elements that evaluate the predicate to TRUE.
	 * @throws SQLException
	 */
	public List<T> filteredSelect(Predicate<T> predicate)
			throws SQLException{
		//Not part of the Shadow API
		List<T> all = _selectAll();
		List<T> result = all.parallelStream().filter(predicate).collect(Collectors.toList());
		return result;
	}

	//TODO
	public void update(T t){

	}

	//TODO
	public void delete(T t){

	}

	//TODO
	public void delete(Filter filter){

	}


	private List<T> _selectAll() 
			throws SQLException{

		String SQL_SELECT_ALL = "SELECT * FROM " + this._table;
		List<T> result = new ArrayList<T>();
		Connection connection = this.dataSource.getConnection();
		PreparedStatement stmt = null;
		stmt = connection.prepareStatement(SQL_SELECT_ALL);
		System.out.println("EXECUTING QUERY: " + stmt.toString());
		ResultSet rs = stmt.executeQuery();
		while (rs.next()) {	
			result.add(createInstance(rs));
		}
		rs.close();
		stmt.close();
		connection.close();
		return result;
	}

	/*
	 * Private aux method for generating the PreparedStatement object.
	 */
	private  PreparedStatement generateInsertPrepareStatement(Connection connection, List<T> t_list) 
			throws SQLException, IllegalArgumentException, IllegalAccessException{

		String sql_begin = "INSERT INTO " + this._table + " (";
		String sql_values_values = ") VALUES (";
		String sql_close = ")";
		String sql_open = ",(";
		String sql_question_marks = "";



		for(int i = 0; i < this._fields_length; i++ ){

			if(autoGeneratedKey && this._id == this._fields[i]){
				continue;
			}

			sql_begin += this._column_names[i];
			sql_question_marks  += "?";

			if(i < this._fields_length - 1){
				sql_begin += ", ";
				sql_question_marks += ",";
			}
		}

		String sql_query = sql_begin + sql_values_values + sql_question_marks + sql_close;

		int size = t_list.size();
		if(size > 1){
			String sql_multiple_values = "";
			for (int i = 1; i < size; i++) {
				sql_multiple_values += sql_open + sql_question_marks + sql_close; 
			}
			sql_query += sql_multiple_values;
		}

		return evalPreparedStatement(connection, sql_query, t_list);
	}

	private T createInstance(ResultSet rs) throws SQLException{
		T t = null;
		try {
			t = this._class.newInstance();
		} catch (InstantiationException | IllegalAccessException e) {
			//TODO
			e.printStackTrace();
		}
		Class<?> returnType = null;
		for (int i = 0; i < this._fields_length; i++) {

			returnType = this._fields[i].getType();
			try {
				if(returnType.equals(int.class) || returnType.equals(Integer.class)){

					this._fields[i].setInt(t, rs.getInt(this._column_names[i]));
				}
				else if(returnType.equals(String.class)){

					this._fields[i].set(t, rs.getString(this._column_names[i]));
				}
				else if(returnType.equals(java.sql.Timestamp.class)){

					this._fields[i].set(t, rs.getTimestamp(this._column_names[i]));

				}
				else if(returnType.equals(BigDecimal.class)){

					this._fields[i].set(t, rs.getBigDecimal(this._column_names[i]));

				}
				else if(returnType.equals(long.class)  || returnType.equals(Long.class) ){

					this._fields[i].setLong(t, rs.getLong(this._column_names[i]));

				}
				else if(returnType.equals(double.class) || returnType.equals(Double.class)){

					this._fields[i].setDouble(t, rs.getDouble(this._column_names[i]));
				}
				else{
					System.err.println("The data type: " + returnType + " is not currently supported");
				}
			} catch (IllegalArgumentException | IllegalAccessException e) {
				//TODO
				e.printStackTrace();

			}		
		}
		return t;
	}

	/*
	 * Private aux method for evaluating the PreparedStatement using the object field values.
	 */
	private PreparedStatement evalPreparedStatement(Connection connection, String sql, List<T> t_list)
			throws SQLException, IllegalArgumentException, IllegalAccessException{

		PreparedStatement stmt = null;

		Class<?> returnType = null;
		stmt = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);

		int stm_pos = 1;
		int i = 0;

		for(T t : t_list){
			i = 0;
			while (i < this._fields_length) {

				if(autoGeneratedKey && this._id == this._fields[i]){
					i++;
					continue;
				}

				returnType = this._fields[i].getType();

				if(returnType.equals(int.class) || returnType.equals(Integer.class)){

					stmt.setInt(stm_pos, this._fields[i].getInt(t));
				}
				else if(returnType.equals(String.class)){

					stmt.setString(stm_pos, (String) this._fields[i].get(t));
				}
				else if(returnType.equals(java.sql.Timestamp.class)){

					stmt.setTimestamp(stm_pos, (java.sql.Timestamp) this._fields[i].get(t));
				}
				else if(returnType.equals(BigDecimal.class)){

					stmt.setBigDecimal(stm_pos, (BigDecimal) this._fields[i].get(t));
				}
				else if(returnType.equals(long.class)  || returnType.equals(Long.class) ){

					stmt.setLong(stm_pos, this._fields[i].getLong(t));
				}
				else if(returnType.equals(double.class) || returnType.equals(Double.class)){

					stmt.setDouble(stm_pos, this._fields[i].getDouble(t));
				}
				else{
					stmt.close();
					System.err.println("The data type: " + returnType + " is not currently supported");
				}

				stm_pos++;
				i++;
			}
		}
		return stmt;
	}
}
