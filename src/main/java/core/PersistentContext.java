package core;

import java.lang.annotation.Annotation;
import java.lang.reflect.Field;
import java.math.BigDecimal;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.List;

import javax.sql.DataSource;
import annotations.ColumnMap;
import annotations.ID;
import annotations.PersistentClass;
import exceptions.NotValidPersistentClassException;

public class PersistentContext<T>  {

	private DataSource dataSource;
	private Field[] _fields;
	private String _table;
	private int _fields_length;
	private String[] _column_names;
	private Field _id;
	private String _id_column_name;
	private boolean autoGeneratedKey;
	private Class<T> _class;


	/**
	 * 
	 * @param datasource
	 * @param _class
	 * @throws NotValidPersistentClassException If the class is not annotated as @PersistentClass or
	 * if the T class doesn't have public getters for all the persistent fields.
	 */
	public PersistentContext(DataSource datasource, Class<T> _class)
			throws NotValidPersistentClassException{

		if(!_class.isAnnotationPresent(PersistentClass.class)){
			throw new NotValidPersistentClassException("The object must be an instance of a class annotated with @PersistentCLass");
		}

		this.dataSource = datasource;
		this._fields = _class.getDeclaredFields();
		Annotation class_an = _class.getAnnotation(PersistentClass.class);
		this._table = ((PersistentClass) class_an).table();
		this._fields_length = this._fields.length;
		this._column_names = new String[this._fields_length];
		this._class = _class;



		Annotation annotation = null;
		boolean found_id = false;
		for(int i = 0; i < this._fields_length; i++ ){
			if(this._fields[i].isAnnotationPresent(ColumnMap.class)){
				this._fields[i].setAccessible(true);
				annotation = this._fields[i].getAnnotation(ColumnMap.class);
				this._column_names[i] = ((ColumnMap) annotation).column();	

				if(this._fields[i].isAnnotationPresent(ID.class)){	
					if(found_id){
						//TODO Allow compound keys.
						throw new NotValidPersistentClassException("Compound keys are not currently supported.");
					}
					this._id_column_name = this._column_names[i];
					this._id =  this._fields[i];
					if(!this._id.getType().equals(long.class) && !this._id.getType().equals(Long.class)){
						throw new NotValidPersistentClassException("The class @ID element must be long when is autogenerated.");
					}
					annotation = this._fields[i].getAnnotation(ID.class);
					this.autoGeneratedKey = ((ID) annotation).autogenerated();	
					found_id = true;
				}

			}
		}
		if(!found_id){
			throw new NotValidPersistentClassException("The class must have an @ID field.");
		}

	}

	/**
	 * 
	 * @param t Generic object to persist
	 * @throws SQLException If an error occurs while accessing the Data Base.
	 * @throws IllegalAccessException 
	 * @throws IllegalArgumentException 
	 * 
	 */
	public void insert(T t)
			throws SQLException{

		long id = 0;

		Connection connection = this.dataSource.getConnection();
		PreparedStatement stmt = null;
		try {
			stmt = generateInsertPrepareStatement(t, connection);
		} catch (IllegalArgumentException  | IllegalAccessException e) {
			//TODO
		}
		if(stmt != null){
			ResultSet rs;
			System.out.println("EXECUTING QUERY: " + stmt.toString());
			stmt.executeUpdate();
			rs = stmt.getGeneratedKeys();

			if (rs.next()) {
				id = rs.getLong(1);
			}	
			rs.close();
			stmt.close();
		}
		connection.close();
		if(this.autoGeneratedKey){
			this._id.setAccessible(true);
			try {
				this._id.setLong(t, id);
			} catch (IllegalArgumentException | IllegalAccessException e) {
				//TODO
			}
		}
	}
	
	/**
	 * 
	 * @param ts List of Generic objects to persist
	 * @throws SQLException If an error occurs while accessing the Data Base.
	 * @throws IllegalAccessException 
	 * @throws IllegalArgumentException 
	 * 
	 */
	public void insert(List<T> ts)
			throws SQLException{
		//TODO: batch
	}


	/**
	 * 
	 * @param t Generic object to persist
	 * @return Auto-generated key created as a result of executing the insert on the Data Base. 0 if no Auto Gererated Key.
	 * @throws SQLException If an error occurs while accessing the Data Base.
	 */
	public long insertAndReturnId(T t)
			throws SQLException{

		long id = 0;

		Connection connection = this.dataSource.getConnection();
		PreparedStatement stmt = null;
		try {
			stmt = generateInsertPrepareStatement(t, connection);
		} catch (IllegalArgumentException  | IllegalAccessException e) {
			//TODO
		}
		if(stmt != null){
			ResultSet rs;
			System.out.println("EXECUTING QUERY: " + stmt.toString());
			stmt.executeUpdate();
			rs = stmt.getGeneratedKeys();

			if (rs.next()) {
				id = rs.getLong(1);
			}
			rs.close();
			stmt.close();
		}
		connection.close();
		if(this.autoGeneratedKey){
			this._id.setAccessible(true);
			try {
				this._id.setLong(t, id);
			} catch (IllegalArgumentException | IllegalAccessException e) {
				//TODO
			}
		}
		return id;
	}

	/**
	 * 
	 * @param id Primary Key of the object T to be fetch on the Data Base.
	 * @return T instance with the data found on the Data Base
	 * @throws SQLException
	 */
	public T selectById(long id)
			throws SQLException{

		T t = null;
		try {
			t = this._class.newInstance();
		} catch (InstantiationException | IllegalAccessException e) {
			//TODO
			e.printStackTrace();
		}

		String selectSQL = "SELECT * FROM " + this._table +" WHERE " + this._id_column_name + " = ?";
		Connection connection = this.dataSource.getConnection();
		PreparedStatement stmt = null;
		stmt = connection.prepareStatement(selectSQL);
		stmt.setLong(1, id);
		System.out.println("EXECUTING QUERY: " + stmt.toString());
		ResultSet rs = stmt.executeQuery();
		if (rs.next()) {
			Class<?> returnType = null;
			for (int i = 0; i < this._fields_length; i++) {

				returnType = this._fields[i].getType();
				try {
					if(returnType.equals(int.class) || returnType.equals(Integer.class)){

						this._fields[i].setInt(t, rs.getInt(this._column_names[i]));
					}
					else if(returnType.equals(String.class)){

						this._fields[i].set(t, rs.getString(this._column_names[i]));
					}
					else if(returnType.equals(java.sql.Timestamp.class)){

						this._fields[i].set(t, rs.getTimestamp(this._column_names[i]));

					}
					else if(returnType.equals(BigDecimal.class)){

						this._fields[i].set(t, rs.getBigDecimal(this._column_names[i]));

					}
					else if(returnType.equals(long.class)  || returnType.equals(Long.class) ){

						this._fields[i].setLong(t, rs.getLong(this._column_names[i]));

					}
					else if(returnType.equals(double.class) || returnType.equals(Double.class)){

						this._fields[i].setDouble(t, rs.getDouble(this._column_names[i]));
					}
					else{
						stmt.close();
						System.err.println("The data type: " + returnType + " is not currently supported");
					}
				} catch (IllegalArgumentException | IllegalAccessException e) {
					//TODO
				}		
			}
		}
		rs.close();
		stmt.close();
		connection.close();
		return t;
	}

	//TODO
	public List<T> select(Filter filter){
		return null;
	}

	//TODO
	public void update(T t){

	}

	//TODO
	public void delete(T t){

	}

	//TODO
	public void delete(Filter filter){

	}


	/*
	 * Private aux method for generating the PreparedStatement object.
	 */
	private PreparedStatement generateInsertPrepareStatement(T t, Connection connection) 
			throws SQLException, IllegalArgumentException, IllegalAccessException{

		String sql_insert_front = "INSERT INTO " + this._table + " (";
		String sql_values = ") VALUES (";
		String sql_end = ")";

		for(int i = 0; i < this._fields_length; i++ ){

			if(autoGeneratedKey && this._id == this._fields[i]){
				continue;
			}
			
			sql_insert_front += this._column_names[i];
			sql_values += "?";

			if(i < this._fields_length - 1){
				sql_insert_front += ", ";
				sql_values +=",";
			}		

		}

		String sql_query = sql_insert_front + sql_values + sql_end;
		return evalPreparedStatement(connection, sql_query, t);
	}

	/*
	 * Private aux method for evaluating the PreparedStatement using the object field values.
	 */
	private PreparedStatement evalPreparedStatement(Connection connection, String sql, T t)
			throws SQLException, IllegalArgumentException, IllegalAccessException{

		PreparedStatement stmt = null;

		Class<?> returnType = null;
		stmt = connection.prepareStatement(sql, Statement.RETURN_GENERATED_KEYS);

		int a = 0;
		for (int i = 0; i < this._fields_length; i++) {
			
			if(autoGeneratedKey && this._id == this._fields[i]){
				a++;
				continue;
			}
			
			returnType = this._fields[i].getType();

			if(returnType.equals(int.class) || returnType.equals(Integer.class)){
				
				stmt.setInt(i + 1 - a, this._fields[i].getInt(t));
			}
			else if(returnType.equals(String.class)){

				stmt.setString(i + 1 - a, (String) this._fields[i].get(t));
			}
			else if(returnType.equals(java.sql.Timestamp.class)){

				stmt.setTimestamp(i + 1 - a, (java.sql.Timestamp) this._fields[i].get(t));
			}
			else if(returnType.equals(BigDecimal.class)){

				stmt.setBigDecimal(i + 1 - a, (BigDecimal) this._fields[i].get(t));
			}
			else if(returnType.equals(long.class)  || returnType.equals(Long.class) ){

				stmt.setLong(i + 1 - a, this._fields[i].getLong(t));
			}
			else if(returnType.equals(double.class) || returnType.equals(Double.class)){

				stmt.setDouble(i + 1 - a, this._fields[i].getDouble(t));
			}
			else{
				stmt.close();
				System.err.println("The data type: " + returnType + " is not currently supported");
			}
		}

		return stmt;
	}
}
